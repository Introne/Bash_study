# 备忘录
## sort命令
sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。
选项：
-u      在输出行中去除重复行     
-r      降序  
-n      数值排序（排除10比2大的情况）  
-t      设定间隔符（在多个描述中选择一列进行排序）  
-f      忽略大小写  
-c      检查文件是否已排好序，如果乱序，则输出第一个乱序的行的相关信息，最后返回1  
-C      检查文件是否已排好序，如果乱序，不输出内容，仅返回1  
-M      以月份来排序，比如JAN小于FEB等等  
-b      忽略每一行前面的所有空白部分，从第一个可见字符开始比较。


## find 命令的基本结构如下：
 Linux 中强大的搜索命令，不仅可以按照文件名搜索文件，还可以按照权限、大小、时间、inode 号等来搜索文件。但是 find 命令是直接在硬盘中进行搜索的，如果指定的搜索范围过大，find命令就会消耗较大的系统资源，导致服务器压力过大。所以，在使用 find 命令搜索时，不要指定过大的搜索范围。

使用： find [paths] [expression] [actions]

find 命令接受一个或多个路径（paths）作为搜索范围，并在该路径下递归地搜索。即检索完指定的目录后，还会对该目录下的子目录进行检索，以及子目录下的子目录。。。直到到达目录树底部。

默认情况下（不带任何搜索条件），find 命令会返回指定目录下的所有文件，所以常常需要通过特定的 expression 对结果进行筛选。


## wc命令

Linux wc命令用于计算字数。

利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为"-"，则wc指令会从标准输入设备读取数据。

语法
wc [-clw][--help][--version][文件...]
参数：

-c或--bytes或--chars 只显示Bytes数  
-l或--lines 显示行数  
-w或--words 只显示字数  
--help 在线帮助  
--version 显示版本信息  

## xargs命令
xargs 是 execute arguments 的缩写，它的作用是从标准输入中读取内容，并将此内容传递给它要协助的命令，并作为那个命令的参数来执行。

## rsync命令
从字面意思上，rsync 可以理解为 remote sync（远程同步），但它不仅可以远程同步数据（类似于 scp 命令），还可以本地同步数据（类似于 cp 命令）。不同于 cp 或 scp 的一点是，使用 rsync 命令备份数据时，不会直接覆盖以前的数据（如果数据已经存在），而是先判断已经存在的数据和新数据的差异，只有数据不同时才会把不相同的部分覆盖。

## GNU与Linux

GNU 是一个操作系统项目（一种计划或者叫运动）, 名字是一个递归的 GNU's Not Unix! 的缩写。在这个旗帜下成立了 FSF，起草了 GPL 等。

90年代,也就是Linux刚诞生的时代.因为Linux上来的用户态(shell/toolchain/text editor)基本上都来自于 GNU 的移植,所以被冠上 GNU/Linux 作为distro的标题,也就是说内核是Linux, 用户态环境都是GNU系,发行版主要区别于软件包管理策略。

## 内核的作用是什么？

内核有 4 项工作：

    内存管理：追踪记录有多少内存存储了什么以及存储在哪里
    进程管理：确定哪些进程可以使用中央处理器（CPU）、何时使用以及持续多长时间
    设备驱动程序：充当硬件与进程之间的调解程序/解释程序
    系统调用和安全防护：从流程接受服务请求

在正确实施的情况下，内核对于用户是不可见的，它在自己的小世界（称为内核空间）中工作，并从中分配内存和跟踪所有内容的存储位置。用户所看到的内容（例如 Web 浏览器和文件）则被称为用户空间。这些应用通过系统调用接口（SCI）与内核进行交互。

举例来说，内核就像是一个为高管（硬件）服务的忙碌的个人助理。助理的工作就是将员工和公众（用户）的消息和请求（进程）转交给高管，记住存放的内容和位置（内存），并确定在任何特定的时间谁可以拜访高管、会面时间有多长。

## 如何理解内核在操作系统中的位置？

为了更具象地理解内核，不妨将 Linux 计算机想象成有三层结构：

    硬件：物理机（这是系统的底层结构或基础）是由内存（RAM）、处理器（或 CPU）以及输入/输出（I/O）设备（例如存储、网络和图形）组成的。其中，CPU 负责执行计算和内存的读写操作。
    Linux 内核：处于操作系统的核心位置。驻留在内存中的软件，用于告诉 CPU 要执行哪些操作。
    用户进程：这些是内核所管理的运行程序。用户进程共同构成了用户空间。用户进程有时也简称为进程。内核还允许这些进程和服务器彼此进行通信（称为进程间通信或 IPC）。

## 单短横和双短横
带短横的是命令选项参数，一个端横的是短选项，二个短横的是长选项，比如：-h 和 --help 

## export命令
在shell中执行程序时，shell会提供一组环境变量。export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该此登陆操作。
参数：
　-f 　代表[变量名称]中为函数名称。
　-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
　-p 　列出所有的shell赋予程序的环境变量123
 
延伸
export设置环境变量是暂时的，只在本次登录中有效，可修改如下文件来使命令长久有效。
 
1. 修改profile文件
#vi /etc/profile1
在里面加入:
```bash
export PATH="$PATH:/opt/au1200_rm/build_tools/bin"1
```
这个在我们的机器上是大家共用的，建议不修改这个，只修改自己根路径下的。
 
2. 修改本id根路径下的.bashrc或.bash_profile文件：
# vi /home/zhaodw/.bash_profile1
在里面加入：
```bash
export PATH="$PATH:/opt/au1200_rm/build_tools/bin"1
```

注意：
1、执行脚本时是在一个子shell环境运行的，脚本执行完后该子shell自动退出；
2、一个shell中的系统环境变量才会被复制到子shell中（用export定义的变量）；
3、一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（并不能返回到父shell中）。
4、不用export定义的变量只对该shell有效，对子shell也是无效的。



## 进程
进程是一个运行着的程序，是代码的动态形式，进程有如下属性：
独立的内核堆栈
进程控制块
独立的存储空间


## export命令

export命令将作为他参数的变量导入到子shell中，并使之在子shell中有效。export命令把自己的参数创建为一个环境变量，而这个环境变量可以被其他脚本和当前程序调用的程序看见。

Linux export命令

功能说明：设置或显示环境变量。

语 法：export [-fnp][变量名称]=[变量设置值]

补充说明：在 shell中执行程序时，shell会提供一组 环境变量。export可新增，修改或删除 环境变量，供后续执行的程序使用。export的效力仅及于该次登录操作。

参 数：
-f 代表[变量名称]中为函数名称。
-n 删除指定的 变量。 变量实际上并未删除，只是不会输出到后续指令的执行环境中。
-p 列出所有的shell赋予程序的 环境变量。


环境变量相关学习链接：
https://www.cnblogs.com/leezx/p/5589941.html
https://blog.csdn.net/u013176681/article/details/38662985
## 文件IO---标准输入、标准输出和标准错误
（1） 每个进程都会默认打开3个文件描述符，即0、1、2。其中0代表标准输入流、1代表标准输出流、2代表标准错误流。通常标准输入流对应着键盘的设备文件、标准输出流和错误流对应着显示器的设备文件。在编程中通常使用宏STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO分别来代表0，1，2。
 
要注意一点：
　　0、1、2这三个文件描述符对应的是标准输入流、标准输出流和标准错误流而不是键盘设备文件和显示器设备文件。只是默认标准输入流对应着键盘设备文件，标准输出和错误对应着显示器设备文件。

　　而一些C库提供的标准IO函数，这些函数操作的是文件描述符，是标准输入流、输出流或者错误流，而不是键盘的设备文件和显示器的设备文件。如果改变了标准输出流和显示器设备文件之间的对应关系，那么可能结果就不会在显示器上。这种情况出现在命令行中使用重定向符号的时候，标准输入、标准输出和标准错误对应的就不是键盘设备文件和显示器设备文件，而是指定的某个普通的文件。

（2）执行一个shell命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），通常对应终端的键盘；
　　标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应终端的屏幕。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。

（3）文件描述符是一个简单的正整数，用以标明每一个被进程所打开的文件和socket。

\>默认为标准输出重定向，与 1>相同

2>&1意思是把 标准错误输出 重定向到 标准输出.

&>file意思是把 标准输出 和 标准错误输出 都重定向到文件file中

2>&1 > file 把错误输出定向到标准输出（此时标准输出为终端,所以输出到终端），标准输出定位到文件

\> file 2>&1 把标准输出定位到文件，错误输出到标准输出（此时标准输出指向文件，所以输出到文件）

（4）经常可以在一些脚本，尤其是在crontab调用时发现如下形式的命令调用/tmp/test.sh > /tmp/test.log 2>&1
前半部分/tmp/test.sh > /tmp/test.log很容易理解，那么后面的2>&1是怎么回事呢？

要解释这个问题，还是得提到文件重定向。我们知道>和<是文件重定向符。那么1和2是什么？在shell中，每个进程都和三个系统文件相关联：标准输入stdin，标准输出stdout和标准错误stderr，三个系统文件的文件描述符分别为0，1和2。所以这里2>&1 的意思就是将标准错误也输出到标准输出当中。

下面通过一个例子来展示2>&1有什么作用：

```bash
$ cat test.sh
t
date
```

test.sh中包含两个命令，其中t是一个不存在的命令，执行会报错，默认情况下，错误会输出到stderr。date则能正确执行，并且输出时间信息，默认输出到stdout
./test.sh > test1.log
./test.sh: line 1: t: command not found

```bash
$ cat test1.log
Tue Oct 9 20:51:50 CST 2007
```
可以看到，date的执行结果被重定向到log文件中了，而t无法执行的错误则只打印在屏幕上。

```bash
$ ./test.sh > test2.log 2>&1
$ cat test2.log
./test.sh: line 1: t: command not found
Tue Oct 9 20:53:44 CST 2007
```
这次，stderr和stdout的内容都被重定向到log文件中了。

实际上， > 就相当于 1> 也就是重定向标准输出，不包括标准错误。通过2>&1，就将标准错误重定向到标准输出了，那么再使用>重定向就会将标准输出和标准错误信息一同重定向了。如果只想重定向标准错误到文件中，则可以使用2> file。

linux shell 中"2>&1"含义
脚本是:
nohup /mnt/Nand3/H2000G >/dev/null 2>&1 &

对于& 1 更准确的说应该是文件描述符 1,而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO),其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了.其中0 表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。

command >out.file 2>&1 &

command >out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。 2>&1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&，是让该命令在后台执行。
    
试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；
换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出.

你可以用

   ls 2>1测试一下，不会报没有2文件的错误，但会输出一个空的文件1；  
   ls xxx 2>1测试，没有xxx这个文件的错误输出到了1中；  
   ls xxx 2>&1测试，不会生成1这个文件了，不过错误跑到标准输出了；    
   ls xxx >out.txt 2>&1, 实际上可换成 ls xxx 1>out.txt 2>&1；重定向符号>默认是1,错误和输出都传到out.txt了。

为何2>&1要写在后面？

command > file 2>&1
   
首先是command > file将标准输出重定向到file中， 2>&1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。  
command 2>&1 >file  
2>&1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。>file 后输出才被重定向到file，但标准错误仍然保持在终端。

用strace可以看到：
1. command > file 2>&1
这个命令中实现重定向的关键系统调用序列是：
open(file) == 3
dup2(3,1)
dup2(1,2)

2. command 2>&1 >file
这个命令中实现重定向的关键系统调用序列是：
dup2(1,2)
open(file) == 3
dup2(3,1)

 

原文链接：http://hi.baidu.com/yanize/blog/item/8727ad86ce49212c66096e3b.html



(5). 把/dev/null看作"黑洞". 它非常等价于一个只写文件. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到. 然而, /dev/null对命令行和脚本都非常的有用.

禁止标准输出.
```bash
 1 cat $filename >/dev/null
   2 # 文件内容丢失，而不会输出到标准输出.

```
禁止标准错误  
```bash
1 rm $badname 2>/dev/null
   2 # 这样错误信息[标准错误]就被丢到太平洋去了.
```

清除日志文件内容
```bash
1 cat /dev/null > /var/log/messages
   2 #  : > /var/log/messages   有同样的效果, 但不会产生新的进程.（因为:是内建的）
   3 
   4 cat /dev/null > /var/log/wtmp
```

(6). linux中快速清空文件内容的几种方法：


##### 1. 通过重定向到 Null 来清空文件内容

清空或者让一个文件成为空白的最简单方式，是像下面那样，通过 shell 重定向 null （不存在的事物）到该文件：

$ > filename 


##### 2. 使用 ‘true' 命令重定向来清空文件

下面我们将使用 : 符号，它是 shell 的一个内置命令，等同于 true 命令，它可被用来作为一个 no-op（即不进行任何操作）。另一种清空文件的方法是将 : 或者 true 内置命令的输出重定向到文件中，具体如下：

$ : > filename 

##### 3. 使用 cat/cp/dd 实用工具及 /dev/null 设备来清空文件
在 Linux 中， null 设备基本上被用来丢弃某个进程不再需要的输出流，或者作为某个输入流的空白文件，这些通常可以利用重定向机制来达到，所以 /dev/null 设备文件是一个特殊的文件，它将清空送到它这里来的所有输入，而它的输出则可被视为一个空文件。另外，你可以通过使用 cat命令 显示 /dev/null 的内容然后重定向输出到某个文件，以此来达到清空该文件的目的。

$ cat /dev/null > filename

##### 4. 使用 echo 命令清空文件

在这里，你可以使用 echo命令 将空字符串的内容重定向到文件中，具体如下：

$ echo "" > filename 
$ echo > filename 


##### 5. 使用 truncate 命令来清空文件内容

truncate 可被用来将一个文件缩小或者扩展到某个给定的大小。
你可以利用它和 -s 参数来特别指定文件的大小。要清空文件的内容，则在下面的命令中将文件的大小设定为 0:
```bash
# truncate -s 0 access.log
```

## 重定向操作符	

说明

\>:将命令输出写入到文件或设备（例如打印机）中，而不是写在命令提示符窗口中。

\<:从文件中而不是从键盘中读入命令输入。

\>>:将命令输出添加到文件末尾而不删除文件中的信息。

\>&:将一个句柄的输出写入到另一个句柄的输入中。

\<&:从一个句柄读取输入并将其写入到另一个句柄输出中。

\|:	从一个命令中读取输出并将其写入另一个命令的输入中。也称作管道。


## 管道符
竖线‘|’ ，在linux中是作为管道符的，将‘|’前面命令的输出作为'|'后面的输入。

双竖线‘||’，用双竖线‘||’分割的多条命令，执行的时候遵循如下规则，如果前一条命令为真，则后面的命令不会执行，如果前一条命令为假，则继续执行后面的命令。


Reference:
find: https://www.jianshu.com/p/ea8cc2248022
