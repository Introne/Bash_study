# Q$A集锦

## 文件IO---标准输入、标准输出和标准错误
（1） 每个进程都会默认打开3个文件描述符，即0、1、2。其中0代表标准输入流、1代表标准输出流、2代表标准错误流。通常标准输入流对应着键盘的设备文件、标准输出流和错误流对应着显示器的设备文件。在编程中通常使用宏STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO分别来代表0，1，2。
 
要注意一点：
　　0、1、2这三个文件描述符对应的是标准输入流、标准输出流和标准错误流而不是键盘设备文件和显示器设备文件。只是默认标准输入流对应着键盘设备文件，标准输出和错误对应着显示器设备文件。

　　而一些C库提供的标准IO函数，这些函数操作的是文件描述符，是标准输入流、输出流或者错误流，而不是键盘的设备文件和显示器的设备文件。如果改变了标准输出流和显示器设备文件之间的对应关系，那么可能结果就不会在显示器上。这种情况出现在命令行中使用重定向符号的时候，标准输入、标准输出和标准错误对应的就不是键盘设备文件和显示器设备文件，而是指定的某个普通的文件。

（2）执行一个shell命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），通常对应终端的键盘；
　　标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应终端的屏幕。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。

（3）文件描述符是一个简单的正整数，用以标明每一个被进程所打开的文件和socket。

最前面的三个文件描述符（0，1，2）分别与标准输入（stdin），标准输出（stdout）和标准错误（stderr）对应

0表示标准输入
1表示标准输出
2表示标准错误输出

\>默认为标准输出重定向，与 1>相同

2>&1意思是把 标准错误输出 重定向到 标准输出.

&>file意思是把 标准输出 和 标准错误输出 都重定向到文件file中

2>&1 > file 把错误输出定向到标准输出（此时标准输出为终端,所以输出到终端），标准输出定位到文件

\> file 2>&1 把标准输出定位到文件，错误输出到标准输出（此时标准输出指向文件，所以输出到文件）

（4）经常可以在一些脚本，尤其是在crontab调用时发现如下形式的命令调用/tmp/test.sh > /tmp/test.log 2>&1
前半部分/tmp/test.sh > /tmp/test.log很容易理解，那么后面的2>&1是怎么回事呢？

要解释这个问题，还是得提到文件重定向。我们知道>和<是文件重定向符。那么1和2是什么？在shell中，每个进程都和三个系统文件相关联：标准输入stdin，标准输出stdout和标准错误stderr，三个系统文件的文件描述符分别为0，1和2。所以这里2>&1 的意思就是将标准错误也输出到标准输出当中。

下面通过一个例子来展示2>&1有什么作用：

```bash
$ cat test.sh
t
date
```

test.sh中包含两个命令，其中t是一个不存在的命令，执行会报错，默认情况下，错误会输出到stderr。date则能正确执行，并且输出时间信息，默认输出到stdout
./test.sh > test1.log
./test.sh: line 1: t: command not found

```bash
$ cat test1.log
Tue Oct 9 20:51:50 CST 2007
```
可以看到，date的执行结果被重定向到log文件中了，而t无法执行的错误则只打印在屏幕上。

```bash
$ ./test.sh > test2.log 2>&1
$ cat test2.log
./test.sh: line 1: t: command not found
Tue Oct 9 20:53:44 CST 2007
```
这次，stderr和stdout的内容都被重定向到log文件中了。

实际上， > 就相当于 1> 也就是重定向标准输出，不包括标准错误。通过2>&1，就将标准错误重定向到标准输出了，那么再使用>重定向就会将标准输出和标准错误信息一同重定向了。如果只想重定向标准错误到文件中，则可以使用2> file。

linux shell 中"2>&1"含义
脚本是:
nohup /mnt/Nand3/H2000G >/dev/null 2>&1 &

对于& 1 更准确的说应该是文件描述符 1,而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO),其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了.其中0 表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。

command >out.file 2>&1 &

command >out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。 2>&1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&，是让该命令在后台执行。
    
试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；
换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出.

你可以用

   ls 2>1测试一下，不会报没有2文件的错误，但会输出一个空的文件1；  
   ls xxx 2>1测试，没有xxx这个文件的错误输出到了1中；  
   ls xxx 2>&1测试，不会生成1这个文件了，不过错误跑到标准输出了；    
   ls xxx >out.txt 2>&1, 实际上可换成 ls xxx 1>out.txt 2>&1；重定向符号>默认是1,错误和输出都传到out.txt了。

为何2>&1要写在后面？

command > file 2>&1
   
首先是command > file将标准输出重定向到file中， 2>&1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。  
command 2>&1 >file  
2>&1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。>file 后输出才被重定向到file，但标准错误仍然保持在终端。

用strace可以看到：
1. command > file 2>&1
这个命令中实现重定向的关键系统调用序列是：
open(file) == 3
dup2(3,1)
dup2(1,2)

2. command 2>&1 >file
这个命令中实现重定向的关键系统调用序列是：
dup2(1,2)
open(file) == 3
dup2(3,1)

 

原文链接：http://hi.baidu.com/yanize/blog/item/8727ad86ce49212c66096e3b.html



(5). 把/dev/null看作"黑洞". 它非常等价于一个只写文件. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到. 然而, /dev/null对命令行和脚本都非常的有用.

禁止标准输出.
```bash
 1 cat $filename >/dev/null
   2 # 文件内容丢失，而不会输出到标准输出.

```
禁止标准错误  
```bash
1 rm $badname 2>/dev/null
   2 # 这样错误信息[标准错误]就被丢到太平洋去了.
```

清除日志文件内容
```bash
1 cat /dev/null > /var/log/messages
   2 #  : > /var/log/messages   有同样的效果, 但不会产生新的进程.（因为:是内建的）
   3 
   4 cat /dev/null > /var/log/wtmp
```

(6). linux中快速清空文件内容的几种方法：


##### 1. 通过重定向到 Null 来清空文件内容

清空或者让一个文件成为空白的最简单方式，是像下面那样，通过 shell 重定向 null （不存在的事物）到该文件：

$ > filename 


##### 2. 使用 ‘true' 命令重定向来清空文件

下面我们将使用 : 符号，它是 shell 的一个内置命令，等同于 true 命令，它可被用来作为一个 no-op（即不进行任何操作）。另一种清空文件的方法是将 : 或者 true 内置命令的输出重定向到文件中，具体如下：

$ : > filename 

##### 3. 使用 cat/cp/dd 实用工具及 /dev/null 设备来清空文件
在 Linux 中， null 设备基本上被用来丢弃某个进程不再需要的输出流，或者作为某个输入流的空白文件，这些通常可以利用重定向机制来达到，所以 /dev/null 设备文件是一个特殊的文件，它将清空送到它这里来的所有输入，而它的输出则可被视为一个空文件。另外，你可以通过使用 cat命令 显示 /dev/null 的内容然后重定向输出到某个文件，以此来达到清空该文件的目的。

$ cat /dev/null > filename

##### 4. 使用 echo 命令清空文件

在这里，你可以使用 echo命令 将空字符串的内容重定向到文件中，具体如下：

$ echo "" > filename 
$ echo > filename 


##### 5. 使用 truncate 命令来清空文件内容

truncate 可被用来将一个文件缩小或者扩展到某个给定的大小。
你可以利用它和 -s 参数来特别指定文件的大小。要清空文件的内容，则在下面的命令中将文件的大小设定为 0:
```bash
# truncate -s 0 access.log
```
